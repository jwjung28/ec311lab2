`timescale 1ns/1ps
module tb_debouncer;
  reg  clk = 0;
  reg  reset = 1;      
  reg  button_in = 0;
  wire button_out;

  // Use a small DEBOUNCE_MAX so you can see activity quickly in sim
  debouncer #(.DEBOUNCE_MAX(8)) dut (
    .clk(clk),
    .reset(reset),
    .button_in(button_in),
    .button_out(button_out)
  );

  // 100 MHz clock (10 ns period)
  always #5 clk = ~clk;

  initial begin
    // Make sure reset is actually sampled low at a falling edge
    @(negedge clk); reset = 0;     // assert
    @(negedge clk); reset = 1;     // release (all regs now known/0)

    // Idle a few cycles
    repeat (4) @(negedge clk);

    // Some short bounce (should NOT trigger)
    button_in = 1; @(negedge clk);
    button_in = 0; @(negedge clk);
    button_in = 1; @(negedge clk);
    button_in = 0; repeat (3) @(negedge clk);

    // Valid press: hold high >= DEBOUNCE_MAX negedges (>= 8 here)
    button_in = 1; repeat (10) @(negedge clk);
    // Release
    button_in = 0; repeat (10) @(negedge clk);

    // Another clean press/release
    button_in = 1; repeat (10) @(negedge clk);
    button_in = 0; repeat (10) @(negedge clk);

    $finish;
  end
endmodule
