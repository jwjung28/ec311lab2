`timescale 1ns/1ps

// -----------------------------------------------------------------------------
// Sim-only *fast* divider shims (compile with +define+SIM_FAST_DIVS)
// These shadow the RTL modules only during simulation builds.
// -----------------------------------------------------------------------------
`ifdef SIM_FAST_DIVS
module clock_divider_1khz (
    input  wire clk,         // ignored
    input  wire reset_n,     // ACTIVE-LOW
    output reg  clk_1khz
);
    initial clk_1khz = 1'b0;
    always begin
        if (!reset_n) begin clk_1khz = 1'b0; @(posedge reset_n); end
        #100 clk_1khz = ~clk_1khz; // ~5 MHz square for quick sim visibility
    end
endmodule

module clock_divider_1hz (
    input  wire clk,         // ignored
    input  wire reset_n,     // ACTIVE-LOW
    output reg  clk_1hz
);
    initial clk_1hz = 1'b0;
    always begin
        if (!reset_n) begin clk_1hz = 1'b0; @(posedge reset_n); end
        #2000 clk_1hz = ~clk_1hz; // "1 Hz" becomes very fast in sim
    end
endmodule
`endif

// -----------------------------------------------------------------------------
// Testbench
// -----------------------------------------------------------------------------
module tb_top_part2;

  // 100 MHz main clock for the DUT
  localparam real TNS = 10.0;  // 10 ns period = 100 MHz
  reg clk_100mhz = 0;
  always #(TNS/2.0) clk_100mhz = ~clk_100mhz;

  // Inputs
  reg reset_n     = 0;   // ACTIVE-LOW global reset
  reg btn_inc     = 0;   // pushbutton
  reg mode_select = 0;   // 0=AUTO, 1=MANUAL

  // Outputs
  wire [3:0] an;
  wire [6:0] seg;

  // DUT (uses monolithic display_control inside)
  top_part2 DUT (
    .clk_100mhz (clk_100mhz),
    .reset_n    (reset_n),
    .btn_inc    (btn_inc),
    .mode_select(mode_select),
    .an         (an),
    .seg        (seg)
  );

  // Handy access to internal counter for printing (sim-only)
  wire [15:0] count16 = DUT.count16;

  // Make the debouncer snappy for sim (tiny dwell)
  defparam DUT.u_db.DEBOUNCE_MAX = 16;

  // helpers
  task cyc(input int n); begin repeat(n) @(posedge clk_100mhz); end endtask;
  task press(input int hold_cycles); begin btn_inc=1; cyc(hold_cycles); btn_inc=0; end endtask;

  integer c0, c1;

  initial begin
    $display("[%0t] start tb_top_part2", $time);

    // Release reset
    cyc(5); reset_n = 1; cyc(5);

    // -------- AUTO MODE: counter advances from sim "1Hz"; button ignored ----
    mode_select = 0; // AUTO
    c0 = count16;
    // Wait some time so the fast-sim 1Hz shim toggles a few times
    cyc(5000);
    c1 = count16;
    if (c1 == c0) $display("FAIL(AUTO): counter did not advance from 1Hz");
    else          $display("PASS(AUTO): counter advanced from %0d to %0d", c0, c1);

    // Button should NOT affect in AUTO
    c0 = count16;
    press(40); cyc(100);
    if (count16 != c0) $display("FAIL(AUTO): button affected count (was %0d now %0d)", c0, count16);
    else               $display("PASS(AUTO): button ignored");

    // -------- MANUAL MODE: debounced pulses count exactly once each ----------
    mode_select = 1; cyc(50);
    c0 = count16;
    press(40); cyc(50);
    press(40); cyc(50);
    press(40); cyc(50);
    if (count16 != c0 + 3)
      $display("FAIL(MANUAL): expected %0d got %0d", c0+3, count16);
    else
      $display("PASS(MANUAL): +3 pulses counted");

    // -------- MODE FLIP NEAR "1Hz" EDGE: no double/missed count -------------
    // Back to AUTO and hover around an edge by waiting ~a couple of us
    mode_select = 0; cyc(200);
    c0 = count16;
    // Flip to MANUAL right around when AUTO edge *might* happen
    mode_select = 1; press(40); mode_select = 0; cyc(500);
    c1 = count16;
    if (c1 < c0 + 1) $display("FAIL(MODE FLIP): missed count");
    else             $display("PASS(MODE FLIP): no obvious double/miss (from %0d to %0d)", c0, c1);

    // Quick smoke on display lines (active-LOW)
    $display("AN=%b SEG=%b COUNT=0x%h", an, seg, count16);

    $display("[%0t] done tb_top_part2", $time);
    cyc(100); $finish;
  end
endmodule

