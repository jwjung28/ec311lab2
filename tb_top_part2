`timescale 1ns/1ps

// ============================================================================
// SIM-ONLY divider overrides
// These replace your RTL clock_divider_1hz/1khz during *simulation only*.
// They ignore the input clk and produce quick test clocks so you donâ€™t
// wait realtime seconds. Keep them in the TB file, not in synthesis.
// ============================================================================
module clock_divider_1khz (
    input  wire clk,         // ignored in sim
    input  wire reset_n,     // ACTIVE-LOW
    output reg  clk_1khz
);
    initial clk_1khz = 1'b0;
    // Fast "1 kHz" for sim: toggle every 100 ns => 5 MHz square (just for visibility)
    // Change the delay to whatever you like.
    always begin
        if (!reset_n) begin
            clk_1khz = 1'b0;
            @(posedge reset_n);
        end
        #100 clk_1khz = ~clk_1khz;
    end
endmodule

module clock_divider_1hz (
    input  wire clk,         // ignored in sim
    input  wire reset_n,     // ACTIVE-LOW
    output reg  clk_1hz
);
    initial clk_1hz = 1'b0;
    // Fast "1 Hz" for sim: toggle every 2,000 ns => 250 kHz square (just for visibility)
    // Adjust as desired to see the counter step faster/slower.
    always begin
        if (!reset_n) begin
            clk_1hz = 1'b0;
            @(posedge reset_n);
        end
        #2000 clk_1hz = ~clk_1hz;
    end
endmodule

// ============================================================================
// Testbench
// ============================================================================
module tb_top_part2;

  // 100 MHz main clock for the DUT
  localparam real TNS = 10.0;  // 10 ns period = 100 MHz
  reg clk_100mhz = 0;
  always #(TNS/2.0) clk_100mhz = ~clk_100mhz;

  // Inputs
  reg reset_n     = 0;   // global ACTIVE-LOW
  reg btn_inc     = 0;   // pushbutton
  reg mode_select = 0;   // 0=AUTO (uses sim "1Hz"), 1=MANUAL (button)

  // Outputs
  wire [3:0] an;
  wire [6:0] seg;

  // DUT
  top_part2 DUT (
    .clk_100mhz (clk_100mhz),
    .reset_n    (reset_n),
    .btn_inc    (btn_inc),
    .mode_select(mode_select),
    .an         (an),
    .seg        (seg)
  );

  // Make the debouncer snappy for sim (tiny dwell)
  defparam DUT.u_db.DEBOUNCE_MAX = 16;

  // Handy access to internal counter for printing (sim-only)
  wire [15:0] count16 = DUT.count16;

  // Helpers
  task cyc(input int n); begin repeat(n) @(posedge clk_100mhz); end endtask
  task press(input int hold_cycles); begin btn_inc=1; cyc(hold_cycles); btn_inc=0; end endtask

  initial begin
    $display("[%0t] start", $time);

    // Release reset
    cyc(5);
    reset_n = 1;

    // -------- AUTO MODE (mode_select=0): driven by sim "1Hz" clock --------
    mode_select = 0;
    cyc(2000);
    $display("[%0t] AUTO mode: count = 0x%h", $time, count16);

    // -------- MANUAL MODE (mode_select=1): debounced button pulses --------
    mode_select = 1;
    cyc(50);

    press(40); cyc(50);
    press(40); cyc(50);
    press(40); cyc(50);

    $display("[%0t] MANUAL mode: count = 0x%h (should be AUTO + 3)", $time, count16);

    // Show current scan and segments (active-LOW)
    $display("AN=%b SEG=%b", an, seg);

    cyc(200);
    $display("[%0t] done", $time);
    $finish;
  end

endmodule
