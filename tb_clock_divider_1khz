module tb_clock_divider_1khz;
  localparam real TNS = 10.0;  // 100 MHz-like sim clock (10 ns period)

  reg  clk = 0;
  reg  reset_n = 0;            // ACTIVE-LOW
  wire clk_1khz;

  // 100 MHz sim clock
  always #(TNS/2.0) clk = ~clk;

  // DUT (SIM VERSION)
  clock_divider_1khz_sim DUT (
    .clk(clk),
    .reset_n(reset_n),
    .clk_1khz(clk_1khz)
  );

  integer hi_cycles, lo_cycles, ok_cnt, i;
  reg prev;

  initial begin
    $display("[%0t] tb_clock_divider_1khz: start", $time);

    // release reset
    repeat (3) @(posedge clk);
    reset_n = 1;
    repeat (1) @(posedge clk);

    ok_cnt = 0;

    // measure 5 full periods: expect LOW=8, HIGH=8 cycles
    for (i = 0; i < 5; i = i + 1) begin
      prev = clk_1khz;

      // count until first toggle
      lo_cycles = 0;
      while (clk_1khz == prev) begin @(posedge clk); lo_cycles = lo_cycles + 1; end

      prev = clk_1khz;
      hi_cycles = 0;
      while (clk_1khz == prev) begin @(posedge clk); hi_cycles = hi_cycles + 1; end

      if (lo_cycles == 8 && hi_cycles == 8) begin
        ok_cnt = ok_cnt + 1;
        $display("OK %0d: LOW=%0d HIGH=%0d (exp 8/8)", i, lo_cycles, hi_cycles);
      end else begin
        $display("MISMATCH %0d: LOW=%0d HIGH=%0d (exp 8/8)", i, lo_cycles, hi_cycles);
      end
    end

    if (ok_cnt == 5) $display("PASS: 1kHz divider timing correct (sim).");
    else             $display("FAIL: %0d/5 periods correct.", ok_cnt);

    #50 $finish;
  end
endmodule
